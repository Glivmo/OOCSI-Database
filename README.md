# OOCSI Database

A "Processing for Pi"-based database for OOCSI. This particular database was designed for use by the Tyria World of the course DBSU10 (2018-3) Technologies for Connectivity. The Database is divided in two distinct functions; saving data that is sent to the database through OOCSI and retrieving saved data from the database.


## Getting Started
Using this database is very easy. You only need to install the [necessary oocsi library](https://github.com/iddi) and you are off to a great start! Please try to get familiar with the possibilities of OOCSI before using this database.


## How to use
OOCSI-Database is divided in two part; database saving and database requesting. First we will learn how to save data to the database.

**Database saving**

To start sending data to the database, you need to use the correct client- channel- and datanames. Every group has one clientname that will work on the database, which is `"Tyria_groupname"`. An example for T01 would be:
```Processing
oocsi = new OOCSI(this, "Tyria_T01" , "oocsi server");
```
Next up is the database channel. For this database you should use the Channel `"Tyria_World_Data"`

An example of sending data in Processing is the following (an Arduino example is [available in the examples](/Examples/Arduino)):
```Processing
timeStamp = int(nf(month(), 1) + nf(day(), 2) + nf(hour(), 2) + nf(minute(), 2) + nf(second(), 2)); // timestamp in mddhhmmss format
long dataOne = 185379023;
String theSecondPieceofData = "Example";
boolean numberThree = true;


  if (prevTimeStamp != timeStamp) {
    oocsi.channel("Tyria_World_Data")
      .data("timeStamp", timeStamp)
      .data("dataNames", "data1,data2,thirdData")
      .data("data1", dataOne)
      .data("data2", theSecondPieceofData)
      .data("thirdData", numberThree)
      .send();
```

This example has a few important things that should be adhered to:

1. The data `"timeStamp"` has to be included. The timestamp should be an integer in an *MDDHHMMSS* format. An example of how to retrieve a timestamp on an ESP from within the OOCSI library will be added later.
2. The data `"dataNames"` has to be included. This string includes all the other datanames, seperated with a comma and no spaces in between. These datanames are necessary for correct data retrieval. 
**IMPORTANT:** Please put the datanames and their types in your own documentation. This way other groups will be able to correctly retrieve your data from the database.

The data sent to the database can be of any type. Inside the database it will be saved as an object and can be retrieved as the original type.


**Database requesting**

To perform a database request you need to have an OOCSIEvent handler set up:
```Processing
void handleOOCSIEvent(OOCSIEvent event) {
  String sender = event.getSender();
  if (sender.equals("Tyria_World_Database")) {
    int requestHandle = event.getInt("requestHandle", -1);
    int timeStamp = event.getInt("timeStamp", -1);
    String dataNames = event.getString("dataNames");
    
    if(event.getString("debug") != null) String debug = event.getString(debug);
    
    long dataOne = (long) event.getInt("data1", -1);
    String theSecondPieceofData = event.getString("data2");
    boolean numberThree = event.getInt("thirdData", false);
  }
}
```
The datanames and datatypes should be provided by the group that owns the module.

To request a value from the database the following message has to be sent:
```Processing
oocsi.channel("Tyria_World_Data_Get")
      .data("stone", 1)
      .data("timeStamp", requestTimeStamp)
      .data("messageHandle", messageHandle)
      .send();
```
Here `"stone"` is the group from which you want to receive the data (in this example T01). `"timeStamp"` is the specific timeStamp you want to receive. `"messageHandle"` is a message handle generated by yourself, by which you will be able to check if you have received the correct response. Preferably, this variable should be different for every request.

As you might have noticed, a string called `"debug"` is also included in the payload. When you request a certain timestamp which happens to not be present in the database, the closest timestamp will be picked. The `"debug"` string will tell you which timestamp was picked:
```
226085512 not found, defaulted to value from 226090000
```

